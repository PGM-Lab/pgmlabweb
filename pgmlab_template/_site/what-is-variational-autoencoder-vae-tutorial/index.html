

<!DOCTYPE html>
<meta charset="utf-8">
<title>Tutorial - What is a variational autoencoder? &#8211; PGM-Lab </title>
<meta name="description" content="Understanding Variational Autoencoders (VAEs) from two perspectives: deep learning and graphical models.">
<meta name="keywords" content="variational inference, autoencoder, neural networks, graphical models, inference, deep learning, machine learning">



<head>

<!-- Twitter Cards -->


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:title" content="Tutorial - What is a variational autoencoder? &#8211; PGM-Lab ">
<meta property="og:description" content="Understanding Variational Autoencoders (VAEs) from two perspectives: deep learning and graphical models.">
<meta property="og:url" content="http://localhost:4000/what-is-variational-autoencoder-vae-tutorial/">
<meta property="og:site_name" content="PGM-Lab ">
<meta property="og:image" content="http://localhost:4000/images/confusion-thumb.png">

<!-- Google authorship -->
<a rel="author" href="https://www.google.com/+JaanAltosaar"></a>

<!-- Google & Bing Verification -->
<meta name="google-site-verification" content="LTwvMh1s7cdUyjaHqQYsBg-I4ZPy0wm_TKUoU0IT5HU#LTwvMh1s7cdUyjaHqQYsBg-I4ZPy0wm_TKUoU0IT5HU">
<meta name="msvalidate.01" content="B3B21CDB59D1FC75DFE9B0D0CC329C8C">
</head>
<link rel="canonical" href="http://localhost:4000/what-is-variational-autoencoder-vae-tutorial/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Subscribe to the PGM-Lab Feed">



<!-- old feed: <link href="http://localhost:4000/feed.xml" target="_blank" type="application/atom+xml" rel="alternate" title="Subscribe to the PGM-Lab RSS Feed"> -->

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Type -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Crimson+Text:400,400italic,700,700italic" rel='stylesheet' type='text/css' />
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel='stylesheet' type='text/css'>
<!-- <link rel="stylesheet" href="http://localhost:4000/assets/css/entypo.css" media="all"> -->
<script async src="https://use.fontawesome.com/0a87e83674.js"></script>
<!-- In order to use Calendas Plus, you must first purchase it. Then, create a font-face package using FontSquirrel.
<link rel='stylesheet' href='http://localhost:4000/assets/cal.css' media='all' />
-->

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/i.css">

<!-- Fresh Squeezed jQuery -->
<script async src="https://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js" type="text/javascript"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>

<script async src="http://localhost:4000/assets/js/auto-render.min.js"></script>

<meta http-equiv="cleartype" content="on">

<script async src="http://localhost:4000/assets/js/main.js"></script>

<!-- Load Modernizr -->
<script async src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">

<div id="bump">
  <body class="">
    <header class="site-header darken">
      <div class="wrap">
        <hgroup>
          <h1><a href="/"><span id="jaan" class="unhilighted">PGM-Lab</span>&nbsp;<span id="altosaar" class="hilighted"></span></a></h1>
        </hgroup>
        <a href="#nav" class="menu"><span class='icons'>☰</span></a>
        
        <nav class="menu" role="navigation">
          <ul>
            <!--<li>
              <a href="/" title="PGM-Lab">Home</a>
            </li>-->
            
            
            
                
                
                <!--<li><a href="http://localhost:4000/about" >Research</a></li> -->
                   
                      <li>
                          <a href="/about" class="subhover" role="button" aria-haspopup="true" aria-expanded="false">Research <span class="caret"></span></a>
                          <ul class="dropdown">
                              
                                  
                                      <li>
                                          <a href="/publications">Papers</a>
                                      </li>
                                  
                              
                                  
                                      <li>
                                          <a href="/talks">Projects</a>
                                      </li>
                                  
                              
                          </ul>
  
                      </li>
                  
            
                
                
                <!--<li><a href="http://localhost:4000/blog" >Education</a></li> -->
                   
                      <li class="">
                          <a href="/blog">Education</a>
                      </li>
                  
            
                
                
                <!--<li><a href="http://localhost:4000/software" >Software</a></li> -->
                   
                      <li class="">
                          <a href="/software">Software</a>
                      </li>
                  
            
                
                
                <!--<li><a href="http://localhost:4000/publications" >Consultancy</a></li> -->
                   
                      <li class="">
                          <a href="/publications">Consultancy</a>
                      </li>
                  
            
                
                
                <!--<li><a href="http://localhost:4000/people" >People</a></li> -->
                   
                      <li class="">
                          <a href="/people">People</a>
                      </li>
                  
            
                
                
                <!--<li><a href="http://localhost:4000/talks" >Contact</a></li> -->
                   
                      <li class="">
                          <a href="/talks">Contact</a>
                      </li>
                  
            
            

          </ul>
        </nav> 
      </div>
    </header>


<section class="article">

  <div class="overlay overlay-lighter"></div>
  <div class="featured-image" style="background-image: url(http://localhost:4000/images/mnist.gif)"></div>


      <article class="wrap post">
        <header class="post-header">
          <hgroup>
            <h1><a href="/what-is-variational-autoencoder-vae-tutorial/">Tutorial - What is a variational autoencoder?</a></h1>
            <br>
            <!-- <p class="date">Published on <span class="date">Jul 18, 2016</span>&nbsp;|&nbsp;By <span itemprop="name" class="fn"><a href="http://localhost:4000/about" title="About " itemprop="url"></a></span> | <a href="/what-is-variational-autoencoder-vae-tutorial/">Permalink</a></p> -->

            <p class="intro">Understanding Variational Autoencoders (VAEs) from two perspectives: deep learning and graphical models.</p>
          </hgroup>
        </header>

        <p>Why do deep learning researchers and probabilistic machine learning folks get confused when discussing variational autoencoders? What is a variational autoencoder? Why is there unreasonable confusion surrounding this term?</p>

<p>There is a conceptual and language gap. The sciences of neural networks and probability models do not have a shared language. My goal is to bridge this idea gap and allow for more collaboration and discussion between these fields, and provide a consistent implementation (<a href="https://github.com/altosaar/vae/blob/master/vae.py">Github link</a>). <em>If many words here are new to you, jump to the <a href="#glossary">glossary</a>.</em></p>

<p>Variational autoencoders are cool. They let us design complex generative models of data, and fit them to large datasets. They can generate images of fictional celebrity faces and high-resolution <a href="http://blog.otoro.net/2016/04/01/generating-large-images-from-latent-vectors/">digital artwork</a>.</p>

<figure>
    <img src="/images/variational-autoencoder-faces.jpg" style="max-width: 50%" />
    <figcaption>Fictional celebrity faces generated by a variational autoencoder (<a href="https://www.youtube.com/watch?v=XNZIN7Jh3Sg">by Alec Radford</a>). </figcaption>
</figure>

<p>These models also yield state-of-the-art machine learning results in <a href="https://arxiv.org/abs/1502.04623">image generation</a> and <a href="https://arxiv.org/abs/1509.08731">reinforcement learning</a>. Variational autoencoders (VAEs) were defined in 2013 by <a href="https://arxiv.org/abs/1312.6114">Kingma et al.</a> and <a href="https://arxiv.org/abs/1401.4082">Rezende et al.</a>.</p>

<p>How can we create a language for discussing variational autoencoders? Let’s think about them first using neural networks, then using variational inference in probability models.</p>

<h3 id="the-neural-net-perspective">The neural net perspective</h3>

<p>In neural net language, a variational autoencoder consists of an encoder, a decoder, and a loss function.</p>

<figure>
    <img src="/images/encoder-decoder.png" />
    <figcaption>The encoder compresses data into a latent space (z). The decoder reconstructs the data given the hidden representation.</figcaption>
</figure>

<p>The <em>encoder</em> is a neural network. Its input is a datapoint <script type="math/tex">x</script>, its output is a hidden representation <script type="math/tex">z</script>, and it has weights and biases <script type="math/tex">\theta</script>. To be concrete, let’s say <script type="math/tex">x</script> is a 28 by 28-pixel photo of a handwritten number. The encoder ‘encodes’ the data which is <script type="math/tex">784</script>-dimensional into a latent (hidden) representation space <script type="math/tex">z</script>, which is much less than <script type="math/tex">784</script> dimensions. This is typically referred to as a ‘bottleneck’ because the encoder must learn an efficient compression of the data into this lower-dimensional space. Let’s denote the encoder <script type="math/tex">q_\theta (z \vert x)</script>. We note that the lower-dimensional space is stochastic: the encoder outputs parameters to <script type="math/tex">q_\theta (z \vert x)</script>, which is a Gaussian probability density. We can sample from this distribution to get noisy values of the representations <script type="math/tex">z</script>.</p>

<p>The <em>decoder</em> is another neural net. Its input is the representation <script type="math/tex">z</script>, it outputs the parameters to the probability distribution of the data, and has weights and biases <script type="math/tex">\phi</script>. The decoder is denoted by <script type="math/tex">p_\phi(x\vert z)</script>. Running with the handwritten digit example, let’s say the photos are black and white and represent each pixel as <script type="math/tex">0</script> or <script type="math/tex">1</script>. The probability distribution of a single pixel can be then represented using a Bernoulli distribution. The decoder gets as input the latent representation of a digit <script type="math/tex">z</script> and outputs <script type="math/tex">784</script> Bernoulli parameters, one for each of the <script type="math/tex">784</script> pixels in the image. The decoder ‘decodes’ the real-valued numbers in <script type="math/tex">z</script> into <script type="math/tex">784</script> real-valued numbers between <script type="math/tex">0</script> and <script type="math/tex">1</script>. Information is lost because it goes from a smaller to a larger dimensionality. How much information is lost? We measure this using the reconstruction log-likelihood <script type="math/tex">\log p_\phi (x\vert z)</script> whose units are nats. This measure tells us how effectively the decoder has learned to reconstruct an input image <script type="math/tex">x</script> given its latent representation <script type="math/tex">z</script>.</p>

<p>The <em>loss function</em> of the variational autoencoder is the negative log-likelihood with a regularizer. Because there are no global representations that are shared by all datapoints, we can decompose the loss function into only terms that depend on a single datapoint <script type="math/tex">l_i</script>. The total loss is then <script type="math/tex">\sum_{i=1}^N l_i</script> for <script type="math/tex">N</script> total datapoints. The loss function <script type="math/tex">l_i</script> for datapoint <script type="math/tex">x_i</script> is:</p>

<script type="math/tex; mode=display">l_i(\theta, \phi) = - E_{z\sim q_\theta(z\vert x_i)}[\log p_\phi(x_i\vert z)] + KL(q_\theta(z\vert x_i) \vert\vert p(z))</script>

<p>The first term is the reconstruction loss, or expected negative log-likelihood of the <script type="math/tex">i</script>-th datapoint. The expectation is taken with respect to the encoder’s distribution over the representations. This term encourages the decoder to learn to reconstruct the data. If the decoder’s output does not reconstruct the data well, it will incur a large cost in this loss function.</p>

<p>The second term is a regularizer that we throw in (we’ll see how it’s derived later). This is the Kullback-Leibler divergence between the encoder’s distribution <script type="math/tex">q_\theta(z\vert x)</script> and <script type="math/tex">p(z)</script>. This divergence measures how much information is lost (in units of nats) when using <script type="math/tex">q</script> to represent <script type="math/tex">p</script>. It is one measure of how close <script type="math/tex">q</script> is to <script type="math/tex">p</script>.</p>

<p>In the variational autoencoder, <script type="math/tex">p</script> is specified as a standard Normal distribution with mean zero and variance one, or <script type="math/tex">p(z) = Normal(0,1)</script>. If the encoder outputs representations <script type="math/tex">z</script> that are different than those from a standard normal distribution, it will receive a penalty in the loss. This regularizer term means ‘keep the representations <script type="math/tex">z</script> of each digit sufficiently diverse’. If we didn’t include the regularizer, the encoder could learn to cheat and give each datapoint a representation in a different region of Euclidean space. This is bad, because then two images of the same number (say a 2 written by different people, <script type="math/tex">2_{alice}</script> and <script type="math/tex">2_{bob}</script>) could end up with very different representations <script type="math/tex">z_{alice}, z_{bob}</script>. We want the representation space of <script type="math/tex">z</script> to be meaningful, so we penalize this behavior. This has the effect of keeping similar numbers’ representations close together (e.g. so the representations of the digit two <script type="math/tex">{z_{alice}, z_{bob}, z_{ali}}</script> remain sufficiently close).</p>

<p>We train the variational autoencoder using gradient descent to optimize the loss with respect to the parameters of the encoder and decoder <script type="math/tex">\theta</script> and <script type="math/tex">\phi</script>. For stochastic gradient descent with step size <script type="math/tex">\rho</script>, the encoder parameters are updated using <script type="math/tex">\theta \leftarrow \theta - \rho \frac{\partial l}{\partial \theta}</script> and the decoder is updated similarly.</p>

<h3 id="the-probability-model-perspective">The probability model perspective</h3>

<p>Now let’s think about variational autoencoders from a probability model perspective. Please forget everything you know about deep learning and neural networks for now. Thinking about the following concepts in isolation from neural networks will clarify things. At the very end, we’ll bring back neural nets.</p>

<p>In the probability model framework, a variational autoencoder contains a specific probability model of data <script type="math/tex">x</script> and latent variables <script type="math/tex">z</script>. We can write the joint probability of the model as <script type="math/tex">p(x, z) = p(x \vert z) p(z)</script>. The generative process can be written as follows.</p>

<p>For each datapoint <script type="math/tex">i</script>:</p>

<ul>
  <li>Draw latent variables <script type="math/tex">z_i \sim p(z)</script></li>
  <li>Draw datapoint <script type="math/tex">x_i \sim p(x\vert z)</script></li>
</ul>

<p>We can represent this as a graphical model:</p>

<figure>
    <img src="/images/graphical-model-variational-autoencoder.png" width="50%" height="40px" style="max-width: 40%" />
    <figcaption>The graphical model representation of the model in the variational autoencoder. The latent variable z is a standard normal, and the data are drawn from p(x|z). The shaded node for X denotes observed data. For black and white images of handwritten digits, this data likelihood is Bernoulli distributed. </figcaption>
</figure>

<p>This is the central object we think about when discussing variational autoencoders from a probability model perspective. The latent variables are drawn from a prior <script type="math/tex">p(z)</script>. The data <script type="math/tex">x</script> have a likelihood <script type="math/tex">p(x \vert z)</script> that is conditioned on latent variables <script type="math/tex">z</script>. The model defines a joint probability distribution over data and latent variables: <script type="math/tex">p(x, z)</script>. We can decompose this into the likelihood and prior: <script type="math/tex">p(x,z) = p(x\vert z)p(z)</script>. For black and white digits, the likelihood is Bernoulli distributed.</p>

<p>Now we can think about inference in this model. The goal is to infer good values of the latent variables given observed data, or to calculate the posterior <script type="math/tex">p(z \vert x)</script>. Bayes says:</p>

<script type="math/tex; mode=display">p(z \vert x) = \frac{p(x \vert z)p(z)}{p(x)}.</script>

<p>Examine the denominator <script type="math/tex">p(x)</script>. This is called the evidence, and we can calculate it by marginalizing out the latent variables: <script type="math/tex">p(x) = \int p(x \vert z) p(z) dz</script>. Unfortunately, this integral requires exponential time to compute as it needs to be evaluated over all configurations of latent variables. We therefore need to approximate this posterior distribution.</p>

<p>Variational inference approximates the posterior with a family of distributions <script type="math/tex">q_\lambda(z \vert x)</script>. The variational parameter <script type="math/tex">\lambda</script> indexes the family of distributions. For example, if <script type="math/tex">q</script> were Gaussian, it would be the mean and variance of the latent variables for each datapoint <script type="math/tex">\lambda_{x_i} = (\mu_{x_i}, \sigma^2_{x_i}))</script>.</p>

<p>How can we know how well our variational posterior <script type="math/tex">q(z \vert x)</script> approximates the true posterior <script type="math/tex">p(z \vert x)</script>? We can use the Kullback-Leibler divergence, which measures the information lost when using <script type="math/tex">q</script> to approximate <script type="math/tex">p</script> (in units of nats):</p>

<script type="math/tex; mode=display">KL(q_\lambda(z \vert x) \vert \vert p(z \vert x)) =</script>

<script type="math/tex; mode=display">\mathbf{E}_q[\log q_\lambda(z \vert x)]- \mathbf{E}_q[\log p(x, z)] + \log p(x)</script>

<p>Our goal is to find the variational parameters <script type="math/tex">\lambda</script> that minimize this divergence. The optimal approximate posterior is thus</p>

<script type="math/tex; mode=display">q_\lambda^* (z \vert x) = {\arg\min}_\lambda KL(q_\lambda(z \vert x) \vert \vert p(z \vert x)).</script>

<p>Why is this impossible to compute directly? The pesky evidence <script type="math/tex">p(x)</script> appears in the divergence. This is intractable as discussed above. We need one more ingredient for tractable variational inference. Consider the following function:</p>

<script type="math/tex; mode=display">ELBO(\lambda) = \mathbf{E}_q[\log p(x, z)] - \mathbf{E}_q[\log q_\lambda(z \vert x)].</script>

<p>Notice that we can combine this with the Kullback-Leibler divergence and rewrite the evidence as</p>

<script type="math/tex; mode=display">\log p(x) = ELBO(\lambda) + KL(q_\lambda(z \vert x) \vert \vert p(z \vert x))</script>

<p>By Jensen’s inequality, the Kullback-Leibler divergence is always greater than or equal to zero. This means that minimizing the Kullback-Leibler divergence is equivalent to maximizing the ELBO. The abbreviation is revealed: the Evidence Lower BOund allows us to do approximate posterior inference. We are saved from having to compute and minimize the Kullback-Leibler divergence between the approximate and exact posteriors. Instead, we can maximize the ELBO which is equivalent (but computationally tractable).</p>

<p>In the variational autoencoder model, there are only local latent variables (no datapoint shares its latent <script type="math/tex">z</script> with the latent variable of another datapoint). So we can decompose the ELBO into a sum where each term depends on a single datapoint. This allows us to use stochastic gradient descent with respect to the parameters <script type="math/tex">\lambda</script> (important: the variational parameters are shared across datapoints - more on this <a href="#mean-field">here</a>). The ELBO for a single datapoint in the variational autoencoder is:</p>

<script type="math/tex; mode=display">ELBO_i(\lambda) = E_{q_\lambda(z\vert x_i)}[\log p(x_i\vert z)] - KL(q_\lambda(z\vert x_i) \vert\vert p(z)).</script>

<p>To see that this is equivalent to our previous definition of the ELBO, expand the log joint into the prior and likelihood terms and use the product rule for the logarithm.</p>

<p>Let’s make the connection to neural net language. The final step is to parametrize the approximate posterior <script type="math/tex">q_\theta (z \vert x, \lambda)</script> with an <em>inference network</em> (or encoder) that takes as input data <script type="math/tex">x</script> and outputs parameters <script type="math/tex">\lambda</script>. We parametrize the likelihood <script type="math/tex">p(x \vert z)</script> with a <em>generative network</em> (or decoder) that takes latent variables and outputs parameters to the data distribution <script type="math/tex">p_\phi(x \vert z)</script>. The inference and generative networks have parameters <script type="math/tex">\theta</script> and <script type="math/tex">\phi</script> respectively. The parameters are typically the weights and biases of the neural nets. We optimize these to maximize the ELBO using stochastic gradient descent (there are no global latent variables, so it is kosher to minibatch our data). We can write the ELBO and include the inference and generative network parameters as:</p>

<script type="math/tex; mode=display">ELBO_i(\theta, \phi) = E_{q_\theta(z\vert x_i)}[\log p_\phi(x_i\vert z)] - KL(q_\theta(z\vert x_i) \vert\vert p(z)).</script>

<p>This evidence lower bound is the negative of the loss function for variational autoencoders we discussed from the neural net perspective; <script type="math/tex">ELBO_i(\theta, \phi) = -l_i(\theta, \phi)</script>. However, we arrived at it from principled reasoning about probability models and approximate posterior inference. We can still interpret the Kullback-Leibler divergence term as a regularizer, and the expected likelihood term as a reconstruction ‘loss’. But the probability model approach makes clear why these terms exist: to minimize the Kullback-Leibler divergence between the approximate posterior <script type="math/tex">q_\lambda(z \vert x)</script> and model posterior <script type="math/tex">p(z \vert x)</script>.</p>

<p>What about the model parameters? We glossed over this, but it is an important point. The term ‘variational inference’ usually refers to maximizing the ELBO with respect to the variational parameters <script type="math/tex">\lambda</script>. We can also maximize the ELBO with respect to the model parameters <script type="math/tex">\phi</script> (e.g. the weights and biases of the generative neural network parameterizing the likelihood). This technique is called variational EM (expectation maximization), because we are maximizing the expected log-likelihood of the data with respect to the model parameters.</p>

<p>That’s it! We have followed the recipe for variational inference. We’ve defined:</p>
<ul>
  <li>a probability model <script type="math/tex">p</script> of latent variables and data</li>
  <li>a variational family <script type="math/tex">q</script> for the latent variables to approximate our posterior</li>
</ul>

<p>Then we used the variational inference algorithm to learn the variational parameters (gradient ascent on the ELBO to learn <script type="math/tex">\lambda</script>). We used variational EM for the model parameters (gradient ascent on the ELBO to learn <script type="math/tex">\phi</script>).</p>

<h3 id="experiments">Experiments</h3>

<p>Now we are ready to look at samples from the model. We have two choices to measure progress: sampling from the prior or the posterior. To give us a better idea of how to interpret the learned latent space, we can visualize what the posterior distribution of the latent variables <script type="math/tex">q_\lambda(z \vert x)</script> looks like.</p>

<p>Computationally, this means feeding an input image <script type="math/tex">x</script> through the inference network to get the parameters of the Normal distribution, then taking a sample of the latent variable <script type="math/tex">z</script>. We can plot this during training to see how the inference network learns to better approximate the posterior distribution, and place the latent variables for the different classes of digits in different parts of the latent space. Note that at the start of training, the distribution of latent variables is close to the prior (a round blob around <script type="math/tex">0</script>).</p>

<center>
<iframe src="//giphy.com/embed/26ufoVqZDjHoPrp8k?html5=true" width="480" height="413" frameborder="0" class="giphy-embed" allowfullscreen=""></iframe>
</center>

<figure>
    <figcaption>Visualizing the learned approximate posterior during training. As training progresses the digit classes become differentiated in the two-dimensional latent space. </figcaption>
</figure>

<p>We can also visualize the prior predictive distribution. We fix the values of the latent variables to be equally spaced between <script type="math/tex">-3</script> and <script type="math/tex">3</script>. Then we can take samples from the likelihood parametrized by the generative network. These ‘hallucinated’ images show us what the model associates with each part of the latent space.</p>

<center>
<iframe src="//giphy.com/embed/26ufgj5LH3YKO1Zlu?html5=true" width="480" height="480" frameborder="0" class="giphy-embed" allowfullscreen=""></iframe>
</center>

<figure>
    <figcaption>Visualizing the prior predictive distribution by looking at samples of the likelihood. The x and y-axes represent equally spaced latent variable values between -3 and 3 (in two dimensions). </figcaption>
</figure>

<h3 id="glossary"><a name="glossary"></a>Glossary</h3>

<p>We need to decide on the language used for discussing variational autoencoders in a clear and concise way. Here is a glossary of terms I’ve found confusing:</p>

<ul>
  <li><strong>Variational Autoencoder (VAE)</strong>: in neural net language, a VAE consists of an encoder, a decoder, and a loss function. In probability model terms, the variational autoencoder refers to approximate inference in a latent Gaussian model where the approximate posterior and model likelihood are parametrized by neural nets (the inference and generative networks).</li>
  <li><strong>Loss function</strong>: in neural net language, we think of loss functions. Training means minimizing these loss functions. But in variational inference, we maximize the <strong>ELBO</strong> (which is not a loss function). This leads to awkwardness like calling <code>optimizer.minimize(-elbo)</code> as optimizers in neural net frameworks only support minimization.</li>
  <li><strong>Encoder</strong>: in the neural net world, the encoder is a neural network that outputs a representation <script type="math/tex">z</script> of data <script type="math/tex">x</script>. In probability model terms, the <strong>inference network</strong> parametrizes the approximate posterior of the latent variables <script type="math/tex">z</script>. The inference network outputs parameters to the distribution <script type="math/tex">q(z \vert x)</script>.</li>
  <li><strong>Decoder</strong>: in deep learning, the decoder is a neural net that learns to reconstruct the data <script type="math/tex">x</script> given a representation <script type="math/tex">z</script>. In terms of probability models, the likelihood of the data <script type="math/tex">x</script> given latent variables <script type="math/tex">z</script> is parametrized by a <strong>generative network</strong>. The generative network outputs parameters to the likelihood distribution <script type="math/tex">p(x \vert z)</script>.</li>
  <li><strong>Local latent variables</strong>: these are the <script type="math/tex">z_i</script> for each datapoint <script type="math/tex">x_i</script>. There are no global latent variables. Because there are only local latent variables, we can easily decompose the ELBO into terms <script type="math/tex">\mathcal{L}_i</script> that depend only on a single datapoint <script type="math/tex">x_i</script>. This enables stochastic gradient descent.</li>
  <li><strong>Inference</strong>: in neural nets, inference usually means prediction of latent representations given new, never-before-seen datapoints. In probability models, inference refers to inferring the values of latent variables given observed data.</li>
</ul>

<p>One jargon-laden concept deserves its own subsection:</p>

<h3 id="mean-field-versus-amortized-inference"><a name="mean-field"></a>Mean-field versus amortized inference</h3>

<!-- TODO: add plate diagrams for mean-field vs amortized inference -->

<p>This issue was very confusing for me, and I can see how it might be even more confusing for someone coming from a deep learning background. In deep learning, we think of inputs and outputs, encoders and decoders, and loss functions. This can lead to fuzzy, imprecise concepts when learning about probabilistic modeling.</p>

<p>Let’s discuss how mean-field inference differs from amortized inference. This is a choice we face when doing approximate inference to estimate a posterior distribution of latent variables. We might have various constraints: do we have lots of data? Do we have big computers or GPUs? Do we have local, per-datapoint latent variables, or global latent variables shared across all datapoints?</p>

<p><strong>Mean-field variational inference</strong> refers to a choice of a variational distribution that factorizes across the <script type="math/tex">N</script> data points, with no shared parameters:</p>

<script type="math/tex; mode=display">q(z) = \prod_i^{N} q(z_i; \lambda_i)</script>

<p>This means there are free parameters for each datapoint <script type="math/tex">\lambda_i</script> (e.g. <script type="math/tex">\lambda_i = (\mu_i, \sigma_i)</script> for Gaussian latent variables). How do we do ‘learning’ for a new, unseen datapoint? We need to maximize the ELBO for each new datapoint, with respect to its mean-field parameter(s) <script type="math/tex">\lambda_i</script>.</p>

<p><strong>Amortized inference</strong> refers to ‘amortizing’ the cost of inference across datapoints. One way to do this is by sharing (amortizing) the variational parameters <script type="math/tex">\lambda</script> across datapoints. For example, in the variational autoencoder, the parameters <script type="math/tex">\theta</script> of the inference network. These global parameters are shared across all datapoints. If we see a new datapoint and want to see what its approximate posterior <script type="math/tex">q(z_i)</script> looks like, we can run variational inference again (maximizing the ELBO until convergence), or trust that the shared parameters are ‘good-enough’. This can be an advantage over mean-field.</p>

<p>Which one is more flexible? Mean-field inference is strictly more expressive, because it has no shared parameters. The per-data parameters <script type="math/tex">\lambda_i</script> can ensure our approximate posterior is most faithful to the data. Another way to think of this is that we are limiting the capacity or representational power of our variational family by tying parameters across datapoints (e.g. with a neural network that shares weights and biases across data).</p>

<h3 id="sample-implementation">Sample implementation</h3>

<p>Here is a simple implementation that was used to generate the figures in this post: <a href="https://github.com/altosaar/vae/blob/master/vae.py">Github link</a></p>

<h3 id="footnote-the-reparametrization-trick">Footnote: the reparametrization trick</h3>

<p>The final thing we need to implement the variational autoencoder is how to take derivatives with respect to the parameters of a stochastic variable. If we are given <script type="math/tex">z</script> that is drawn from a distribution <script type="math/tex">q_\theta (z \vert x)</script>, and we want to take derivatives of a function of <script type="math/tex">z</script> with respect to <script type="math/tex">\theta</script>, how do we do that? The <script type="math/tex">z</script> sample is fixed, but intuitively its derivative should be nonzero.</p>

<p>For some distributions, it is possible to reparametrize samples in a clever way, such that the stochasticity is independent of the parameters. We want our samples to deterministically depend on the parameters of the distribution. For example, in a normally-distributed variable with mean <script type="math/tex">\mu</script> and standard devation <script type="math/tex">\sigma</script>, we can sample from it like this:</p>

<script type="math/tex; mode=display">z = \mu + \sigma \odot \epsilon,</script>

<p>where <script type="math/tex">\epsilon \sim Normal(0, 1)</script>. Going from <script type="math/tex">\sim</script> denoting a draw from the distribution to the equals sign <script type="math/tex">=</script> is the crucial step. We have defined a function that depends on on the parameters deterministically. We can thus take derivatives of functions involving <script type="math/tex">z</script>, <script type="math/tex">f(z)</script> with respect to the parameters of its distribution <script type="math/tex">\mu</script> and <script type="math/tex">\sigma</script>.</p>

<figure>
    <img src="/images/reparametrization.png" />
    <figcaption>The reparametrization trick allows us to push the randomness of a normally-distributed random variable z into epsilon, which is sampled from a standard normal. Diamonds indicate deterministic dependencies, circles indicate random variables. </figcaption>
</figure>

<p>In the variational autoencoder, the mean and variance are output by an inference network with parameters <script type="math/tex">\theta</script> that we optimize. The reparametrization trick lets us backpropagate (take derivatives using the chain rule) with respect to <script type="math/tex">\theta</script> through the objective (the ELBO) which is a function of samples of the latent variables <script type="math/tex">z</script>.</p>

<p>Is anything in this article confusing or can any explanation be improved? Please submit a <a href="https://github.com/altosaar/jaan.io/blob/master/_posts/blog/2016-07-18-what-is-variational-autoencoder-vae-tutorial.md">pull request</a>, <a href="https://twitter.com/thejaan">tweet me</a>, or <a href="mailto:altosaar@princeton.edu">email me</a> :)</p>

<h3 id="references-for-ideas-and-figures">References for ideas and figures</h3>

<p>Many ideas and figures are from Shakir Mohamed’s excellent blog posts on the <a href="http://blog.shakirm.com/2015/10/machine-learning-trick-of-the-day-4-reparameterisation-tricks/">reparametrization trick</a> and <a href="http://blog.shakirm.com/2015/03/a-statistical-view-of-deep-learning-ii-auto-encoders-and-free-energy/">autoencoders</a>.
Durk Kingma created the great visual of the <a href="http://dpkingma.com/?page_id=277">reparametrization trick</a>. Great references for variational inference are this <a href="https://arxiv.org/abs/1601.00670">tutorial</a> and David Blei’s <a href="https://www.cs.princeton.edu/courses/archive/fall11/cos597C/lectures/variational-inference-i.pdf">course notes</a>. Dustin Tran has a helpful blog post on <a href="http://dustintran.com/blog/denoising-criterion-for-variational-auto-encoding-framework/">variational autoencoders</a>. The header’s MNIST gif is from <a href="https://github.com/RuiShu/variational-autoencoder">Rui Shu</a>.</p>

<p><em>Thanks to Rajesh Ranganath, Ben Poole, Jon Berliner, Cassandra Xia, and Ryan Sepassi for discussions and many concepts in this article.</em></p>

<p>Discussion on <a href="https://news.ycombinator.com/edit?id=12292576">Hacker News</a> and <a href="https://www.reddit.com/r/MachineLearning/comments/4xv5b5/explainer_of_variational_autoencoders_from_a/">Reddit</a>. Featured in David Duvenaud’s course syllabus on <a href="http://www.cs.toronto.edu/~duvenaud/courses/csc2541/">“Differentiable inference and generative models”</a>.</p>


      <!--<div class="sharet"><a class="share" href="https://twitter.com/intent/tweet?text=https://jaan.io/what-is-variational-autoencoder-vae-tutorial/+%40thejaan" target ="_blank" data-dnt="true"><i class="icon-twitter"></i></a>&nbsp;&nbsp;&nbsp;<a class="share" href="https://www.facebook.com/sharer/sharer.php?u=https://jaan.io/what-is-variational-autoencoder-vae-tutorial/" target="_blank"><i class="icon-facebook"></i></a>&nbsp;&nbsp;&nbsp;</div>-->

      <!--<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>-->

      

      </article>
    </section>
</div>
<script>
    var scripts = document.getElementsByTagName("script");
    for (var i = 0; i < scripts.length; i++) {
      /* TODO: keep going after an individual parse error. */
      var script = scripts[i];
      if (script.type.match(/^math\/tex/)) {
        var text = script.text === "" ? script.innerHTML : script.text;
        var options = script.type.match(/mode\s*=\s*display/) ?
                      {displayMode: true} : {};
        script.insertAdjacentHTML("beforebegin",
                                  katex.renderToString(text, options));
      }
    }
    document.body.className += " math_finished";
</script>

<div class="push"></div>
  <footert>
  <footer>
    <!--<aside class="wrap">
      <ol class="prev-posts">
        <p class="list-title"><a href="/">Recent Articles</a></p>
        
            <li>
              <span class="recent-title"><a href="http://localhost:4000/antonio/" title="Antonio Salmerón">Antonio Salmerón</span>
              <span class="date">Jan 23, 2019</a></span>
            </li>
        
            <li>
              <span class="recent-title"><a href="http://localhost:4000/data-science/" title="PhD Program">PhD Program</span>
              <span class="date">Jan 23, 2019</a></span>
            </li>
        
            <li>
              <span class="recent-title"><a href="http://localhost:4000/rafa-rumi/" title="Rafael Rumí">Rafael Rumí</span>
              <span class="date">Jan 22, 2019</a></span>
            </li>
        
      </ol>

      <div class="social">
        <ul>
            <li><a href="http://localhost:4000/about"><span class="foot-link">About</span></a></li>

            <li><a href="http://localhost:4000/articles"><span class="foot-link">Articles</span></a></li>

            <li><a id="mail" href="https://jaan.io/feed.xml"><span class="foot-link">Subscribe</span></a></li>



            


            
        </ul>
    </div>
    </aside>-->
    <!-- <small>&copy; 2019 <a href="mailto:jaan@jaan.io">  </a></small> -->
    <small><a href="http://localhost:4000/blog">back to blog </a><a href="https://twitter.com/thejaan" target="_blank"><i class="fa fa-twitter"></i></a></small>
  </footer>
</footert>

  <!-- If they're out, get some from the cellar -->
  <script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
  <script src="http://localhost:4000/assets/js/retina.min.js"></script>

  <!-- Custom JS -->
  <script async src="http://localhost:4000/assets/js/scripts.js"></script>


  
  <!-- Asynchronous Google Analytics snippet -->
  <script>
    var _gaq = _gaq || [];
    var pluginUrl =
    '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
    _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
    _gaq.push(['_setAccount', 'UA-34129661-2']);
    _gaq.push(['_trackPageview']);

  setTimeout(function() {
    window.onscroll = function() {
      window.onscroll = null; // Only track the event once
      _gaq.push(['_trackEvent', 'scroll', 'read']);
    }
  }, 5000);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  

  </body>
</html>
